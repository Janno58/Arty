#pragma once
////////////////////////////////////////////////////////////////////////////////
#include <SFML/System/Vector2.hpp>
#include <cmath>


////////////////////////////////////////////////////////////////////////////////
template <class T>
struct Vec2 {

    ////////////////////////////////////////////////////////////////////////////
    constexpr Vec2() : x(0), y(0) { }

    ////////////////////////////////////////////////////////////////////////////
    constexpr Vec2(T xPos, T yPos) : x(xPos), y(yPos) { }

    ////////////////////////////////////////////////////////////////////////////
    constexpr Vec2(const sf::Vector2<T>& vec) : x(vec.x), y(vec.y) { }

    ////////////////////////////////////////////////////////////////////////////
    Vec2<T> operator+(Vec2<T> rhs) const {
        return {x + rhs.x, y + rhs.y};
    }

    ////////////////////////////////////////////////////////////////////////////
    sf::Vector2f operator-() const {
        return -sf::Vector2f(x, y);
    }

    ////////////////////////////////////////////////////////////////////////////
    Vec2<T> operator-(Vec2<T> rhs) const {
        return {x - rhs.x, y - rhs.y};
    }

    ////////////////////////////////////////////////////////////////////////////
    void operator*=(T rhs) {
        x *= rhs;
        y *= rhs;
    }

    ////////////////////////////////////////////////////////////////////////////
    operator sf::Vector2f() const {
        return {x, y};
    }

    ////////////////////////////////////////////////////////////////////////////
    T x;

    ////////////////////////////////////////////////////////////////////////////
    T y;
};

////////////////////////////////////////////////////////////////////////////////
using Vec2f = Vec2<float>;
using Vec2u = Vec2<unsigned int>;

////////////////////////////////////////////////////////////////////////////////
template <class T>
Vec2<T> operator/(Vec2<T> vec, float div) {
    return {vec.x / div, vec.y / div};
}


////////////////////////////////////////////////////////////////////////////////
template <class T>
Vec2<T> operator*(Vec2<T> vec, float mul) {
    return {vec.x * mul, vec.y * mul};
}

////////////////////////////////////////////////////////////////////////////////
template <class T>
Vec2<T>& operator+=(Vec2<T>& lhs, Vec2<T> rhs) {
    lhs.x += rhs.x;
    lhs.y += rhs.y;
    return lhs;
}


////////////////////////////////////////////////////////////////////////////////
template <class T>
float Length(T vec) {
    return std::sqrt( (vec.x * vec.x) + (vec.y * vec.y) );
}

////////////////////////////////////////////////////////////////////////////////
template <class T>
float Distance(T vec, T vec2) {
    return std::sqrt( std::pow(vec2.x - vec.x, 2) + std::pow(vec2.y - vec.y, 2));
}


////////////////////////////////////////////////////////////////////////////////
template <class T>
T Normalize(T vec) {
    auto mag = Length(vec);

    if(mag == 0) {
        return vec;
    }

    return vec / mag;
}

////////////////////////////////////////////////////////////////////////////////
inline float AngleBetweenVectors(Vec2f vec1, Vec2f vec2) {
    const auto unitVec = vec1 - vec2;
    const float degreesToRads = 180.F / M_PI;
    return std::atan2(unitVec.y, unitVec.x) * degreesToRads;
}

////////////////////////////////////////////////////////////////////////////////
inline Vec2f RotateAroundPoint(Vec2f origin, Vec2f point, float angle) {
    const float angleToRads = M_PI / 180.F;
    angle *= angleToRads;
    auto translated = point - origin;
    Vec2f result{0, 0};
    result.x = (translated.x * std::cos(angle)) - (translated.y * std::sin(angle)) + origin.x;
    result.y = (translated.y * std::cos(angle)) + (translated.x * std::sin(angle)) + origin.y;

    return result;
}